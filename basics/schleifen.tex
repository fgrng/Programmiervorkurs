\lesson{Schleifen}

Wir können mit bedingten Anweisungen den Kontrollfluss schon hilfreich
beeinflussen. Aber nicht alle Dinge, die wir unseren Computer anweisen wollen zu
tun, können wir alleine mit bedingten Anweisungen ausdrücken. Wir können zwar
zum Beispiel testen, ob eine Zahl, eine andere teilt. Was aber, wenn wir testen
wollen, ob eine Zahl eine Primzahl ist? Wir könnten jetzt beginnen, jede Menge
bedingter Anweisungen zu machen, „ist die Zahl durch 2 teilbar, wenn ja, dann
ist es keine, sonst teste, ob sie durch 3 teilbar ist, wenn ja, dann ist es
keine, sonst teste, ob sie durch 5 teilbar ist, wenn ja, dann ist es
keine\dots“, aber es sollte offensichtlich sein, dass wir so nur endlich viele
Teilbarkeiten überprüfen können. Wir müssen zwar in der Tat für jede Zahl nur
endlich viele Teiler überprüfen, aber wenn die Zahl von der Nutzerin eingegeben
wird, wissen wir im Voraus nicht, wie viele das zur Laufzeit sind!

Für solche Aufgaben wurden Schleifen erfunden. Sie sind ein Mittel, um eine
Menge von Anweisungen häufig auszuführen, solange eine von uns fest gelegte
Bedingung erfüllt ist. Wenn wir zum Beispiel testen wollen, ob eine Zahl eine
Primzahl ist, wäre ein einfacher Algorithmus die so genannte „Probedivision“:
Gehe von 2 aufwärts alle Zahlen die kleiner sind, als die Eingabe durch, teste,
ob sie die Eingabe teilen -- wenn ja, dann handelt es sich nicht um eine
Primzahl. Haben wir alle Zahlen ohne Erfolg durchprobiert, muss es sich um eine
Primzahl handeln. Wir können das wieder in einem Kontrollflussdiagramm
ausdrücken ($n$ ist dabei die zu testende Zahl, $i$ ist der Teiler, den wir
gerade testen wollen):

\begin{center}
    \begin{tikzpicture}[auto, node distance=3cm,>=latex']
        \tikzstyle{block} = [draw, fill=blue!20, rectangle, minimum height=3em, minimum width=6em]

        \node [block] (start) {$i = 2$};
        \node [block, right of=start] (cond) {$i < n$?};
        \node [block, right of=cond, node distance=3.5cm] (if) {$i\mid n$?};
        \node [block, right of=if, node distance=4cm] (nope) {$n$ keine Primzahl};
        \node [block, below of=if, node distance=2cm] (incr) {$i \leftarrow i+1$};
        \node [block, above of=nope, node distance=2cm] (yipp) {$n$ Primzahl};

        \draw [->] (start) -- node {} (cond);
        \draw [->] (cond) -- node {ja} (if);
        \draw [->] (cond) |- node [near end] {nein} (yipp);
        \draw [->] (if) -- node {ja} (nope);
        \draw [->] (if) -- node {nein} (incr);
        \draw [->] (incr) -| node {} (cond);
    \end{tikzpicture}
\end{center}
Das Besondere an Schleifen ist, dass sie geschlossene Kreise in
Kontrollflussdiagramm erlauben. Das wiederum erlaubt es uns, die gleiche
Anweisung beliebig oft zu wiederholen.

\pagebreak

Wenn wir dieses Kontrollflussdiagramm in \Java gießen, sieht das so aus:

\javasect{control/Schleifen.java}{27}{42}

Wie wir sehen, sind Schleifen auch nicht viel schwieriger zu handhaben, als
bedingte Anweisungen. Statt \texttt{if} schreiben wir nun \texttt{while}, sonst
ändert sich am Quellcode nicht viel.

Als kleine Nebenbemerkung sei hier gestattet, dass ihr hiermit nun alle Dinge
kennengelernt habt, um \emph{Turing-vollständig} programmieren zu können, d.h.
ihr könnt alleine mit den Mitteln, die ihr bisher kennen gelernt
habt, \emph{jeden} möglichen Algorithmus besschreiben, den wir intuitiv als
solchen bezeichnen würden!

\textbf{Praxis:}
\begin{enumerate}
\item Versucht, die Arbeitsweise eines Debuggers im Kopf zu simulieren. Geht selbst den
  Quellcode Zeile für Zeile durch, überlegt euch, was die Zeile tut und welchen
  Inhalt die Variablen haben. Überlegt euch dann, wohin der Computer (bei
  Kontrollflussstrukturen) als nächstes springen würde.
\item Warum funktioniert das Programm für den Fall $n = 2$?
\end{enumerate}

\textbf{Spiel:}
\begin{enumerate}
\item Das Programm funktioniert noch nicht korrekt, wenn man 1 eingibt (denn 1
  ist keine Primzahl). Modifiziert es so, sodass es auch für die Eingabe 1
  funktioniert.
\item Schreibt selbst ein Programm, welches eine Zahl von der Nutzerin
  entgegennimmt und dann alle Zahlen bis zu dieser Zahl ausgibt. Modifiziert
  Euer Programm, sodass es von dieser Zahl bis zu 0 hinunterzählt.
\item Kompiliert \texttt{WhileTrue.java} und führt es aus. Was beobachtet ihr?
  Warum? (Ihr könnt das Programm abbrechen, indem ihr auf das rote Blocksymbol
  im unteren Teilfenstor „Konsole“ drückt.)
  \inputjava{cotrol/WhileTrue.java}
\end{enumerate}
